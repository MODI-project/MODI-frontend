import { useRef, useState } from "react";
import ExifReader from "exifreader";
import { useNavigate } from "react-router-dom";
import styles from "./DiaryWritePage.module.css";
import Header from "../../components/common/Header";
import { useDiaryDraft } from "../../hooks/useDiaryDraft";
import PrimaryButton from "../../components/common/button/ButtonBar/PrimaryButton";
import AddressInput from "../../components/DiaryPage/DetailPage/AddressInput";
import KeywordInput from "../../components/DiaryPage/DetailPage/KeywordInput";
import Popup from "../../components/common/Popup";
import { autoGenerateDiary } from "../../apis/Diary/autoGenerate";

const DiaryWritePage = () => {
  const fileInputRef = useRef<HTMLInputElement | null>(null);
  const kakaoKey = import.meta.env.VITE_KAKAO_API_KEY;
  const navigate = useNavigate();
  const [showEmptyContentPopup, setShowEmptyContentPopup] = useState(false);
  const [isPopupOpen, setIsPopupOpen] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [popupGenerating, setPopupGenerating] = useState(false);
  const [showUnchangedPopup, setShowUnchangedPopup] = useState(false);

  const handlePopupConfirm = () => {
    setIsPopupOpen(false);
    navigate("/home");
  };

  const { draft, setDraft } = useDiaryDraft();

  // 비활성화 조건
  const isReadyToSubmit =
    draft.image && draft.address.trim() !== "" && draft.keywords.length > 2;

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    setDraft({ imageFile: file, imageChanged: true });

    // 1. 원본 File 객체 저장 (FormData 전송용)
    setDraft({ imageFile: file });

    // 2. 미리보기 용 base64 URL 생성
    const reader = new FileReader();
    reader.onload = async () => {
      const imageUrl = reader.result as string;
      setDraft({ image: imageUrl });

      // 3. GPS 정보 추출
      try {
        const arrayBuffer = await file.arrayBuffer();
        const tags = await ExifReader.load(arrayBuffer);

        const latRaw = tags["GPSLatitude"]?.value as [number, number][];
        const lonRaw = tags["GPSLongitude"]?.value as [number, number][];

        if (
          Array.isArray(latRaw) &&
          Array.isArray(lonRaw) &&
          latRaw.length === 3 &&
          lonRaw.length === 3
        ) {
          const parse = (dms: [number, number][]): number[] =>
            dms.map(([num, den]) => num / den);

          const lat = parse(latRaw);
          const lon = parse(lonRaw);

          const latRef = tags["GPSLatitudeRef"]?.description || "N";
          const lonRef = tags["GPSLongitudeRef"]?.description || "E";

          const latitude = convertDMSToDD(lat, latRef);
          const longitude = convertDMSToDD(lon, lonRef);

          reverseGeocode(latitude, longitude);
        } else {
          alert("GPS 정보가 없는 사진입니다. 주소를 수동으로 입력해주세요.");
        }
      } catch (err) {
        console.error("GPS 정보 추출 실패", err);
      }
    };

    reader.readAsDataURL(file); // base64 미리보기 용
  };

  const convertDMSToDD = (dms: number[], ref: string) => {
    const [degrees, minutes, seconds] = dms;
    let dd = degrees + minutes / 60 + seconds / 3600;
    if (ref === "S" || ref === "W") dd *= -1;
    return dd;
  };

  const reverseGeocode = async (lat: number, lon: number) => {
    try {
      if (!kakaoKey) {
        console.error("Kakao API 키가 설정되지 않았습니다.");
        return;
      }

      const res = await fetch(
        `https://dapi.kakao.com/v2/local/geo/coord2address.json?x=${lon}&y=${lat}`,
        {
          headers: {
            Authorization: `KakaoAK ${kakaoKey}`,
          },
        }
      );

      const data = await res.json();
      const addressName = data.documents?.[0]?.address?.address_name;
      if (addressName) {
        setDraft({ address: addressName });
      } else {
        alert("주소를 찾을 수 없어요.");
      }
    } catch (err) {
      console.error("역지오코딩 실패", err);
    }
  };

  const autoGenerateContent = async () => {
    if (draft.keywords.length < 3) return null;
    setIsGenerating(true);
    try {
      const content = await autoGenerateDiary(draft.keywords);
      if (content) {
        setDraft({ content });
        return content;
      }
      return null;
    } catch (err) {
      console.error("자동 생성 실패", err);
      return null;
    } finally {
      setIsGenerating(false);
    }
  };

  return (
    <div className={styles.DiaryWrite_wrapper}>
      <div className={styles.DiaryWrite_container}>
        <Header
          left="/icons/back.svg"
          LeftClick={() => navigate(-1)}
          middle="기록 작성하기"
          right="/icons/X.svg"
          RightClick={() => setIsPopupOpen(true)}
        />
        <div className={styles.main_container}>
          {/* 사진 첨부 */}
          <div
            className={styles.photo_upload_box}
            onClick={() => fileInputRef.current?.click()}
          >
            {draft.image ? (
              <img
                src={draft.image}
                alt="preview"
                className={styles.preview_image}
              />
            ) : (
              <div className={styles.upload_placeholder}>
                <img src="/icons/plus.svg" alt="plus" />
                <span className={styles.label}>사진 첨부</span>
              </div>
            )}
          </div>
          <input
            type="file"
            accept="image/*"
            ref={fileInputRef}
            style={{ display: "none" }}
            onChange={handleFileChange}
          />

          {/* 주소 입력 */}
          <AddressInput />

          {/* 키워드 */}
          <KeywordInput />

          {/* 내용 */}
          <div className={styles.input_group}>
            <label className={styles.input_label}>내용을 입력해주세요</label>
            <textarea
              placeholder="텍스트 미입력 시 일기가 자동생성돼요"
              value={draft.content}
              onChange={(e) => setDraft({ content: e.target.value })}
              className={styles.textarea}
              rows={4}
            />
          </div>
          <div
            className={`${
              draft.keywords.length < 3
                ? styles.autogen_container
                : styles.only_autogen_container
            }`}
          >
            {draft.keywords.length < 3 && (
              <p className={styles.warning}>
                <img src="/icons/danger.svg" className={styles.warning_icon} />
                생성하려면 키워드가 필요해요
              </p>
            )}
            <button
              className={styles.autogen_button}
              disabled={draft.keywords.length < 3 || isGenerating}
              onClick={async () => {
                if (draft.keywords.length < 3) return;
                await autoGenerateContent();
              }}
            >
              <img src="/icons/rotate_gray.svg" />
              {isGenerating ? "생성 중..." : "자동 생성"}
            </button>
          </div>

          {/* 다음 버튼 */}
          <div className={styles.button_area}></div>
        </div>
        <PrimaryButton
          location="next"
          label="다음"
          onClick={async () => {
            if (
              draft.mode === "edit" &&
              (draft.originalContent ?? "").trim() === draft.content.trim()
            ) {
              setShowUnchangedPopup(true);
              return;
            }

            if (draft.content.trim() === "") {
              setShowEmptyContentPopup(true);
            } else {
              navigate("/style");
            }
          }}
          disabled={!isReadyToSubmit || isGenerating}
        />
      </div>

      {/* 내용 변경 없음 팝업 */}
      {showUnchangedPopup && (
        <Popup
          title={["일기 내용이 변경되지 않았어요!", "넘어가시겠어요?"]}
          buttons={[
            {
              label: "아니요",
              onClick: () => setShowUnchangedPopup(false),
            },
            {
              label: "예",
              onClick: () => {
                setShowUnchangedPopup(false);
                navigate("/style");
              },
            },
          ]}
        />
      )}

      {/* 팝업 */}
      {isPopupOpen && (
        <Popup
          title={[
            draft.mode === "edit"
              ? "수정한 일기가 저장되지 않아요!"
              : "작성한 일기가 저장되지 않아요!",
            "화면을 닫을까요?",
          ]}
          buttons={[
            { label: "아니오", onClick: () => setIsPopupOpen(false) },
            { label: "예", onClick: handlePopupConfirm },
          ]}
        />
      )}

      {/* 팝업 */}
      {showEmptyContentPopup && (
        <Popup
          title={["내용이 입력되지 않았어요!", "넘어가시겠어요?"]}
          description="입력되지 않은 내용은 자동으로 생성돼요"
          buttons={[
            {
              label: "아니요",
              onClick: () => {
                if (popupGenerating) return; // 진행 중이면 막기
                setShowEmptyContentPopup(false);
              },
            },
            {
              label: popupGenerating ? "생성 중..." : "예",
              onClick: async () => {
                if (popupGenerating) return;
                setPopupGenerating(true);
                const content = await autoGenerateContent();
                if (content && content.trim() !== "") {
                  setPopupGenerating(false);
                  setShowEmptyContentPopup(false);
                  navigate("/style");
                } else {
                  setPopupGenerating(false);
                }
              },
            },
          ]}
        />
      )}
    </div>
  );
};

export default DiaryWritePage;
