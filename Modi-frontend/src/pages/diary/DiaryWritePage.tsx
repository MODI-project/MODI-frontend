import { useState } from "react";
import { useNavigate } from "react-router-dom";
import styles from "./DiaryWritePage.module.css";
import Header from "../../components/common/Header";
import PrimaryButton from "../../components/common/button/ButtonBar/PrimaryButton";
import AddressInput from "../../components/DiaryPage/DetailPage/AddressInput";
import KeywordInput from "../../components/DiaryPage/DetailPage/KeywordInput";
import Popup from "../../components/common/Popup";
import PhotoUploader from "../../components/DiaryPage/DetailPage/PhotoUploader";
import { useDiaryDraft } from "../../hooks/useDiaryDraft";
import { autoGenerateDiary } from "../../apis/Diary/autoGenerate";
import { generateSummary } from "../../apis/Diary/summary";
import {
  extractGpsFromFile,
  reverseGeocodeDongOnly,
} from "../../utils/gpsUtils";
import Loading from "../../components/DiaryPage/Loading";

const DiaryWritePage = () => {
  const kakaoKey = import.meta.env.VITE_KAKAO_API_KEY;
  const navigate = useNavigate();
  const { draft, setDraft } = useDiaryDraft();
  const [loading, setLoading] = useState(false);
  const [showEmptyContentPopup, setShowEmptyContentPopup] = useState(false);
  const [isPopupOpen, setIsPopupOpen] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [popupGenerating, setPopupGenerating] = useState(false);
  const [showUnchangedPopup, setShowUnchangedPopup] = useState(false);

  const handlePopupConfirm = () => {
    setIsPopupOpen(false);
    navigate("/home");
  };

  const equalArray = (a: string[] = [], b: string[] = []) =>
    a.length === b.length &&
    a.every((v, i) => v.trim() === (b[i] ?? "").trim());

  const isDraftUnchanged = () => {
    if (draft.mode !== "edit") return false;

    const sameContent =
      (draft.originalContent ?? "").trim() === (draft.content ?? "").trim();
    const sameAddress =
      (draft.originalAddress ?? "").trim() === (draft.address ?? "").trim();
    const sameKeywords = equalArray(
      draft.originalKeywords ?? [],
      draft.keywords ?? []
    );
    const sameImage =
      !draft.imageChanged &&
      (draft.originalImage ?? null) === (draft.image ?? null);
    const sameEmotion = (draft.originalEmotion ?? "") === (draft.emotion ?? "");

    return (
      sameContent && sameAddress && sameKeywords && sameImage && sameEmotion
    );
  };

  const isReadyToSubmit =
    draft.image && draft.address.trim() !== "" && draft.keywords.length > 2;

  const handleFileSelect = async (file: File) => {
    setDraft({ imageFile: file, imageChanged: true });

    const reader = new FileReader();
    reader.onload = () => setDraft({ image: reader.result as string });
    reader.readAsDataURL(file);

    const gps = await extractGpsFromFile(file);
    if (gps) {
      setDraft({ latitude: gps.lat, longitude: gps.lon });
      const addr = await reverseGeocodeDongOnly(gps.lat, gps.lon, kakaoKey);
      if (addr) setDraft({ address: addr });
    } else {
      alert("GPS 정보가 없는 사진입니다. 주소를 수동으로 입력해주세요.");
    }
  };

  const autoGenerateContent = async () => {
    if (draft.keywords.length < 3) return null;
    setIsGenerating(true);
    try {
      const content = await autoGenerateDiary(draft.keywords);
      if (content) {
        setDraft({ content });
        return content;
      }
      return null;
    } catch (err) {
      console.error("자동 생성 실패", err);
      return null;
    } finally {
      setIsGenerating(false);
    }
  };

  const handleNext = async () => {
    if (draft.mode === "edit" && isDraftUnchanged()) {
      setShowUnchangedPopup(true);
      return;
    }

    if (!draft.content?.trim()) {
      setShowEmptyContentPopup(true);
      return;
    }

    try {
      setLoading(true);
      if (draft.content?.trim()) {
        const summary = await generateSummary(draft.content);
        if (summary) {
          setDraft({ noEmotionSummary: summary });
        }
      }

      navigate("/style");
    } catch (e) {
      console.error("다음 단계 이동 실패:", e);
      navigate("/style");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className={styles.DiaryWrite_wrapper}>
      <div className={styles.DiaryWrite_container}>
        <Header
          left="/icons/back.svg"
          LeftClick={() => navigate(-2)} // 감정 태그 선택화면으로 되돌아감
          middle="기록하기"
          right="/icons/X.svg"
          RightClick={() => setIsPopupOpen(true)}
        />
        <div className={styles.main_container}>
          <PhotoUploader image={draft.image} onFileSelect={handleFileSelect} />
          <AddressInput />
          <KeywordInput />

          <div className={styles.input_group}>
            <label className={styles.input_label}>내용을 입력해주세요</label>
            <textarea
              placeholder="텍스트 미입력 시 일기가 자동생성돼요"
              value={draft.content}
              onChange={(e) => setDraft({ content: e.target.value })}
              className={styles.textarea}
              rows={4}
            />
          </div>

          <div
            className={`${
              draft.keywords.length < 3
                ? styles.autogen_container
                : styles.only_autogen_container
            }`}
          >
            {draft.keywords.length < 3 && (
              <p className={styles.warning}>
                <img src="/icons/danger.svg" className={styles.warning_icon} />
                생성하려면 키워드가 필요해요
              </p>
            )}
            <button
              className={styles.autogen_button}
              disabled={draft.keywords.length < 3 || isGenerating}
              onClick={async () => {
                if (draft.keywords.length < 3) return;
                await autoGenerateContent();
              }}
            >
              <img src="/icons/rotate_gray.svg" />
              {isGenerating ? "생성 중..." : "자동 생성"}
            </button>
          </div>
        </div>

        <PrimaryButton
          location="next"
          label="다음"
          onClick={handleNext}
          disabled={!isReadyToSubmit || isGenerating}
        />
      </div>

      {/* 로딩 모달 */}
      {loading && <Loading />}

      {/* 팝업들 */}
      {showUnchangedPopup && (
        <Popup
          title={["기록 내용이 변경되지 않았어요!", "정말 넘어가시겠어요?"]}
          buttons={[
            {
              label: "예",
              onClick: () => {
                setShowUnchangedPopup(false);
                navigate("/style");
              },
            },
            { label: "아니요", onClick: () => setShowUnchangedPopup(false) },
          ]}
        />
      )}
      {isPopupOpen && (
        <Popup
          title={[
            draft.mode === "edit"
              ? "수정된 기록이 저장되지 않아요!"
              : "작성된 기록이 저장되지 않아요!",
            "정말 종료하시겠어요?",
          ]}
          buttons={
            draft.mode === "edit"
              ? [
                  { label: "예", onClick: handlePopupConfirm },
                  { label: "아니오", onClick: () => setIsPopupOpen(false) },
                ]
              : [
                  { label: "아니오", onClick: () => setIsPopupOpen(false) },
                  { label: "예", onClick: handlePopupConfirm },
                ]
          }
        />
      )}
      {showEmptyContentPopup && (
        <Popup
          title={["내용이 입력되지 않았어요!", "정말 넘어가시겠어요?"]}
          description="입력되지 않은 내용은 자동으로 생성돼요"
          buttons={[
            { label: "아니요", onClick: () => setShowEmptyContentPopup(false) },
            {
              label: popupGenerating ? "생성 중..." : "예",
              onClick: async () => {
                if (popupGenerating) return;
                setPopupGenerating(true);
                try {
                  const content = await autoGenerateContent();
                  if (content && content.trim() !== "") {
                    setDraft({ content });

                    setShowEmptyContentPopup(false);
                    setPopupGenerating(false);
                    setLoading(true);

                    const summary = await generateSummary(content);
                    if (summary) {
                      setDraft({ noEmotionSummary: summary });
                    }

                    navigate("/style");
                  }
                } catch (err) {
                  console.error("자동 생성 + 요약 실패", err);
                  setPopupGenerating(false);
                } finally {
                  setLoading(false);
                }
              },
            },
          ]}
        />
      )}
    </div>
  );
};

export default DiaryWritePage;
